from plyfile import PlyData
from ply_tools import *
import os
import struct
import numpy as np
import open3d as o3d
import math
import cv2
from keras.models import Sequential,load_model
import pandas as pd
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from plyfile import PlyData, PlyElement
import json


### required functions

def segment_trays(filename):
    pcd = o3d.io.read_point_cloud(filename)

def modify_ply_from_Phenospex(input_filename, output_filename):
  """ read Phenospex point cloud PLY file"""
  """ read header from input file, delete SPACE in header, write to output file in PLY format"""

  with open(input_filename, "br") as f:   #open input file
    s = f.read()
    end_spaces = s.find(b'\x65\x6E\x64\x5F\x68\x65\x61\x64\x65\x72\x0A')  #find end_heder
    start_spaces = s.find(b'\x76\x65\x72\x74\x65\x78\x5F\x69\x6E\x64\x65\x78\x0A') + 13  #find sequence of spaces
    s= s.replace(s[:end_spaces], s[:start_spaces])   #delete spaces
    f.close()
  with open(output_filename, "bw") as f:   #write modified content to output file
    f.write(s[::])
    f.close()
  return output_filename

def read_ply_header_obj_info(filename):
     """ read Phenospex point cloud PLY file, header"""
     """ return string array contains obj_info elements """
     """ input file in modified format: modify_ply_from_Phenospex, modify header to readable format"""
     assert(os.path.isfile(filename))
     with open(filename, 'rb') as f:
        plydata = PlyData.read(f)
        obj_info = plydata.obj_info
     return obj_info

def read_ply_vertex_all(filename):
    """ read Phenospex point cloud PLY file, all property """
    """ return array of vertices """
    """ input file in modified format: modify_ply_from_Phenospex, modify header to readable format"""
    assert(os.path.isfile(filename))
    with open(filename, 'rb') as f:
        plydata = PlyData.read(f)
        num_verts = plydata['vertex'].count
        vertices = np.zeros(shape=[num_verts, 18], dtype=np.float32)
        vertices[:,0] = plydata['vertex'].data['x']
        vertices[:,1] = plydata['vertex'].data['y']
        vertices[:,2] = plydata['vertex'].data['z']
        vertices[:,3] = plydata['vertex'].data['intensity']
        vertices[:,4] = plydata['vertex'].data['profile']
        vertices[:,5] = plydata['vertex'].data['x_pos']
        vertices[:,6] = plydata['vertex'].data['red']
        vertices[:,7] = plydata['vertex'].data['green']
        vertices[:,8] = plydata['vertex'].data['blue']
        vertices[:,9] = plydata['vertex'].data['nir']
        vertices[:,10] = plydata['vertex'].data['ndvi']
        vertices[:,11] = plydata['vertex'].data['wvl1']
        vertices[:,12] = plydata['vertex'].data['wvl2']
        vertices[:,13] = plydata['vertex'].data['wvl3']
        vertices[:,14] = plydata['vertex'].data['wvl4']
        vertices[:,15] = plydata['vertex'].data['wvl5']
        vertices[:,16] = plydata['vertex'].data['wvl6']
        vertices[:,17] = plydata['vertex'].data['wvl7']
    return vertices

def write_ply_from_vertex(output_filename, vertex, obj_info):
    with open(output_filename, 'bw') as f:
           # Write header  .ply file
          f.write(bytes('ply\n', 'utf-8'))
          f.write(bytes('format binary_little_endian 1.0\n', 'utf-8'))
          # Write header comment
          f.write(bytes('comment PLY data file generated by Phenospex PlantEye modified by KIT CZU\n', 'utf-8'))
          # Write header obj_info
          for obj in obj_info:
            f.write(bytes('obj_info ','utf-8'))
            f.write(bytes(obj,'utf-8'))
            f.write(bytes('\n', 'utf-8'))
          # Write header vertex
          f.write(bytes('element vertex ', 'utf-8'))
          f.write(bytes(str(len(vertex)), 'utf-8'))
          f.write(bytes('\n', 'utf-8'))
          # Write header property list
          f.write(bytes('property float x\n', 'utf-8'))
          f.write(bytes('property float y\n', 'utf-8'))
          f.write(bytes('property float z\n', 'utf-8'))
          f.write(bytes('property uchar intensity\n', 'utf-8'))
          f.write(bytes('property int profile\n', 'utf-8'))
          f.write(bytes('property int x_pos\n', 'utf-8'))
          f.write(bytes('property uchar red\n', 'utf-8'))
          f.write(bytes('property uchar green\n', 'utf-8'))
          f.write(bytes('property uchar blue\n', 'utf-8'))
          f.write(bytes('property uchar nir\n', 'utf-8'))
          f.write(bytes('property uchar ndvi\n', 'utf-8'))
          f.write(bytes('property ushort wvl1\n', 'utf-8'))
          f.write(bytes('property ushort wvl2\n', 'utf-8'))
          f.write(bytes('property ushort wvl3\n', 'utf-8'))
          f.write(bytes('property ushort wvl4\n', 'utf-8'))
          f.write(bytes('property ushort wvl5\n', 'utf-8'))
          f.write(bytes('property ushort wvl6\n', 'utf-8'))
          f.write(bytes('property ushort wvl7\n', 'utf-8'))
          #Write element face 0
          f.write(bytes('element face 0\n', 'utf-8'))
          f.write(bytes('property list uchar int vertex_index\n', 'utf-8'))
          f.write(bytes('end_header\n', 'utf-8'))
          #Write 3D points from vertex to .ply file
          for i in range (vertex.shape[0]):
           f.write(bytearray(struct.pack("f", vertex[i,0]))) # x coordinate
           f.write(bytearray(struct.pack("f", vertex[i,1]))) # y coordinate
           f.write(bytearray(struct.pack("f", vertex[i,2]))) # z coordinate
           f.write(bytearray(struct.pack("B", round(vertex[i,3])))) # intesity
           f.write(bytearray(struct.pack("i", round(vertex[i,4])))) # profile
           f.write(bytearray(struct.pack("i", round(vertex[i,5])))) # x_pos
           f.write(bytearray(struct.pack("B",round(vertex[i,6])))) #  r from RGB
           f.write(bytearray(struct.pack("B",round(vertex[i,7])))) #  g from RGB
           f.write(bytearray(struct.pack("B",round(vertex[i,8])))) #  b from RGB
           f.write(bytearray(struct.pack("B",round(vertex[i,9])))) # nir
           f.write(bytearray(struct.pack("B",round(vertex[i,10])))) # ndvi
           f.write(bytearray(struct.pack("H",round(vertex[i,11])))) # wvl1
           f.write(bytearray(struct.pack("H",round(vertex[i,12])))) # wvl2
           f.write(bytearray(struct.pack("H",round(vertex[i,13])))) # wvl3
           f.write(bytearray(struct.pack("H",round(vertex[i,14])))) # wvl4
           f.write(bytearray(struct.pack("H",round(vertex[i,15])))) # wvl5
           f.write(bytearray(struct.pack("H",round(vertex[i,16])))) # wvl6
           f.write(bytearray(struct.pack("H",round(vertex[i,17])))) # wvl7
    f.close()
    return output_filename

def rotate(origin, point, angle):
    """
    Rotate a point counterclockwise by a given angle around a given origin.

    The angle should be given in radians.
    """
    ox, oy = origin
    px, py = point

    qx = ox + math.cos(angle) * (px - ox) - math.sin(angle) * (py - oy)
    qy = oy + math.sin(angle) * (px - ox) + math.cos(angle) * (py - oy)
    return qx, qy

def convert_obj_info_2_dict(obj_info):
    fileInfo = {}
    for line in obj_info:
        words = line.replace(",", " ").replace(":", " ").replace("  ", " ").split(" ")
        for j,word in enumerate(words):
            if word.find("marker_x_start") > -1:
                fileInfo["marker_x_start"] = float(words[j + 1])
            elif word.find("marker_y_start") > -1:
                fileInfo["marker_y_start"] = float(words[j + 1])
            elif word.find("marker_z_start") > -1:
                fileInfo["marker_z_start"] = float(words[j + 1])

            elif word.find("marker_x_stop") > -1:
                fileInfo["marker_x_stop"] = float(words[j + 1])
            elif word.find("marker_y_stop") > -1:
                fileInfo["marker_y_stop"] = float(words[j + 1])
            elif word.find("marker_z_stop") > -1:
                fileInfo["marker_z_stop"] = float(words[j + 1])

            elif word.find("field_y_origin") > -1:
                fileInfo["field_y_origin"] = float(words[j + 1])
            elif word.find("field_z_origin") > -1:
                fileInfo["field_z_origin"] = float(words[j + 1])
            elif word.find("field_x_origin") > -1:
                fileInfo["field_x_origin"] = float(words[j + 1])

            elif word.find("field_x_period") > -1:
                fileInfo["field_x_period"] = float(words[j + 1])
            elif word.find("field_y_period") > -1:
                fileInfo["field_y_period"] = float(words[j + 1])
            elif word.find("field_z_period") > -1:
                fileInfo["field_z_period"] = float(words[j + 1])

            elif word.find("ref_x_start") > -1:
                fileInfo["ref_x_start"] = float(words[j + 1])
            elif word.find("ref_y_start") > -1:
                fileInfo["ref_y_start"] = float(words[j + 1])
            elif word.find("ref_z_start") > -1:
                fileInfo["ref_z_start"] = float(words[j + 1])

            elif word.find("ref_x_stop") > -1:
                fileInfo["ref_x_stop"] = float(words[j + 1])
            elif word.find("ref_y_stop") > -1:
                fileInfo["ref_y_stop"] = float(words[j + 1])
            elif word.find("ref_z_stop") > -1:
                if words[j + 1].find("}") > -1:
                    fileInfo["ref_z_stop"] = float(words[j + 1][:-2])
                else:
                    fileInfo["ref_z_stop"] = float(words[j + 1])
            elif word.find("y_sectors") > -1:
                if words[j + 1].find("}") > -1:
                    fileInfo["y_sectors"] = float(words[j + 1][:-1])
                else:
                    fileInfo["y_sectors"] = float(words[j + 1])

            elif word.find("pitch_pe") > -1:
                fileInfo["pitch_pe"] = float(words[j + 1])
    return fileInfo

def convert_obj_info_2_dict_new(obj_info,line_seperator=","):
    fileInfo = {}
    for line in obj_info:
        words = line.split(line_seperator)
        for j,word in enumerate(words):
            if word.find("marker_x_start")>-1:
                fileInfo["marker_x_start"]=float(word.split(":")[1])
            elif word.find("marker_y_start")>-1:
                fileInfo["marker_y_start"]=float(word.split(":")[1])
            elif word.find("marker_z_start")>-1:
                fileInfo["marker_z_start"]=float(word.split(":")[1])

            elif word.find("marker_x_stop")>-1:
                fileInfo["marker_x_stop"]=float(word.split(":")[1])
            elif word.find("marker_y_stop")>-1:
                fileInfo["marker_y_stop"]=float(word.split(":")[1])
            elif word.find("marker_z_stop")>-1:
                fileInfo["marker_z_stop"]=float(word.split(":")[1])

            elif word.find("field_y_origin") > -1:
                fileInfo["field_y_origin"] = float(word.split(":")[1])
            elif word.find("field_z_origin") > -1:
                fileInfo["field_z_origin"] = float(word.split(":")[1])
            elif word.find("field_x_origin") > -1:
                fileInfo["field_x_origin"] = float(word.split(":")[1])

            elif word.find("field_x_period") > -1:
                fileInfo["field_x_period"] = float(word.split(":")[1])
            elif word.find("field_y_period") > -1:
                fileInfo["field_y_period"] = float(word.split(":")[1])
            elif word.find("field_z_period") > -1:
                fileInfo["field_z_period"] = float(word.split(":")[1])

            elif word.find("ref_x_start") > -1:
                fileInfo["ref_x_start"] = float(word.split(":")[1])
            elif word.find("ref_y_start") > -1:
                fileInfo["ref_y_start"] = float(word.split(":")[1])
            elif word.find("ref_z_start") > -1:
                fileInfo["ref_z_start"] = float(word.split(":")[1])

            elif word.find("ref_x_stop") > -1:
                fileInfo["ref_x_stop"] = float(word.split(":")[1])
            elif word.find("ref_y_stop") > -1:
                fileInfo["ref_y_stop"] = float(word.split(":")[1])
            elif word.find("ref_z_stop") > -1:
                if words[j + 1].find("}") > -1:
                    fileInfo["ref_z_stop"] = float(word.split(":")[1])
                else:
                    fileInfo["ref_z_stop"] = float(word.split(":")[1])
            elif word.find("y_sectors") > -1:
                fileInfo["y_sectors"] = float(word.split(":")[1][:-1])

            elif word.find("pitch_pe") > -1:
                fileInfo["pitch_pe"] = float(word.split(":")[1])
    return fileInfo

def rotate2originPhenospex(input_filename, output_filename,line_seperator=" "):
    header_obj_info = read_ply_header_obj_info(input_filename)
    if line_seperator==" ":
        fileGlobals=convert_obj_info_2_dict(header_obj_info)
    else:
        fileGlobals=convert_obj_info_2_dict_new(header_obj_info,line_seperator)

    marker_x_start = fileGlobals["marker_x_start"]
    marker_x_stop = fileGlobals["marker_x_stop"]

    marker_z_start = fileGlobals["marker_z_start"]
    marker_z_stop = fileGlobals["marker_z_stop"]

    marker_x = (marker_x_start + marker_x_stop) / 2
    marker_z = (marker_z_start + marker_z_stop) / 2
    angle = fileGlobals["pitch_pe"]
    # verts = read_ply_vertex_all(input_filename)
    ply=PlyFile()
    ply.load(input_filename)

    x, z = rotate([marker_x, marker_z], [ply.vertices['x'], ply.vertices['z']], (-angle / 180) * math.pi)
    ply.vertices['x'] = x - marker_x
    ply.vertices['z'] = z - marker_z

    ply.write(output_filename)

def rotate2origin(input_filename, output_filename,line_seperator=" "):
    header_obj_info = read_ply_header_obj_info(input_filename)
    if line_seperator==" ":
        fileGlobals=convert_obj_info_2_dict(header_obj_info)
    else:
        fileGlobals=convert_obj_info_2_dict_new(header_obj_info,line_seperator)

    marker_x_start = fileGlobals["marker_x_start"]
    marker_x_stop = fileGlobals["marker_x_stop"]

    marker_z_start = fileGlobals["marker_z_start"]
    marker_z_stop = fileGlobals["marker_z_stop"]

    marker_x = (marker_x_start + marker_x_stop) / 2
    marker_z = (marker_z_start + marker_z_stop) / 2
    angle = fileGlobals["pitch_pe"]
    # verts = read_ply_vertex_all(input_filename)
    pcd = o3d.io.read_point_cloud(input_filename)
    verts=np.asarray(pcd.points)

    x, z = rotate([marker_x, marker_z], [verts[:, 0], verts[:, 2]], (-angle / 180) * math.pi)
    verts[:, 0] = x - marker_x
    verts[:, 2] = z - marker_z

    vectors = o3d.utility.Vector3dVector(verts.astype(np.float32))
    pcd.points=vectors
    # write_ply_from_vertex(output_filename, verts, header_obj_info)
    o3d.io.write_point_cloud(output_filename, pcd)

def rotate2origin_new(input_filename, output_filename,line_seperator=" "):
    temp= PlyFile()
    temp.load(input_filename)

    header_obj_info = read_ply_header_obj_info(input_filename)
    if line_seperator==" ":
        fileGlobals=convert_obj_info_2_dict(header_obj_info)
    else:
        fileGlobals=convert_obj_info_2_dict_new(header_obj_info,line_seperator)

    marker_x_start = fileGlobals["marker_x_start"]
    marker_x_stop = fileGlobals["marker_x_stop"]

    marker_z_start = fileGlobals["marker_z_start"]
    marker_z_stop = fileGlobals["marker_z_stop"]

    marker_x = (marker_x_start + marker_x_stop) / 2
    marker_z = (marker_z_start + marker_z_stop) / 2
    angle = fileGlobals["pitch_pe"]
    x, z = rotate([marker_x, marker_z], [temp.vertices["x"], temp.vertices["z"]], (-angle / 180) * math.pi)
    temp.vertices["x"] = x - marker_x
    temp.vertices["z"] = z - marker_z

    temp.write(output_filename)

def voxelization(input_filename, output_filename,voxelsize=2):
    pcd = o3d.io.read_point_cloud(input_filename)
    pcd = pcd.voxel_down_sample(voxel_size=voxelsize)
    o3d.io.write_point_cloud(output_filename, pcd)

def voxelization4Paris(input_filename, output_filename,voxelsize=2):
    df = pd.read_csv(input_filename, header=None)
    point_data = df.to_numpy()
    # Create an Open3D point cloud from the NumPy array
    point_cloud = o3d.geometry.PointCloud()
    point_cloud.points = o3d.utility.Vector3dVector(point_data[:, :3])  # Set x, y, z coordinates
    point_cloud.colors = o3d.utility.Vector3dVector(point_data[:, [3, 4, 4]])  # Set intensity as color
    voxelized_Data = point_cloud.voxel_down_sample(voxel_size=voxelsize)

    # Extract point coordinates and colors from the Open3D point cloud
    points = np.asarray(voxelized_Data.points)
    colors = np.asarray(voxelized_Data.colors)
    # Combine point coordinates and colors into a new NumPy array
    new_data = np.column_stack((points, colors[:, :2]))

    new_data[:,4] = np.round(new_data[:, 4]).astype(int)
    np.savetxt(output_filename, new_data, delimiter=',', fmt='%.2f')

def smoothing(input_filename, output_filename,adj_count=250):

    pcd = o3d.io.read_point_cloud(input_filename)

    # weights = np.array([1, 1, 20])
    # scaled_pcd = o3d.geometry.PointCloud()
    # scaled_pcd.points = o3d.utility.Vector3dVector(np.asarray(pcd.points) * weights)
    # scaled_pcd.colors = o3d.utility.Vector3dVector(np.asarray(pcd.colors))
    # scaled_pcd_tree = o3d.geometry.KDTreeFlann(scaled_pcd)

    pcd_tree = o3d.geometry.KDTreeFlann(pcd)
    for i in range(np.asarray(pcd.points).shape[0]):
        adj_index = pcd_tree.search_knn_vector_3d(pcd.points[i], adj_count)
        # adj_index = scaled_pcd_tree.search_knn_vector_3d(scaled_pcd.points[i], adj_count)
        colors = np.mean(np.asarray(pcd.colors)[adj_index[1], :], axis=0)
        pcd.colors[i] = colors
    print(input_filename+" is done")
    o3d.io.write_point_cloud(output_filename, pcd)
    # o3d.io.write_point_cloud(output_filename[:-5]+"_weight_"+output_filename[-5:], scaled_pcd)

def smoothingPhenospex(input_filename, output_filename,adj_count=250):

    #read and apply smoothing
    pcd = o3d.io.read_point_cloud(input_filename)
    pcd_tree = o3d.geometry.KDTreeFlann(pcd)
    for i in range(np.asarray(pcd.points).shape[0]):
        adj_index = pcd_tree.search_knn_vector_3d(pcd.points[i], adj_count)
        # adj_index = scaled_pcd_tree.search_knn_vector_3d(scaled_pcd.points[i], adj_count)
        colors = np.mean(np.asarray(pcd.colors)[adj_index[1], :], axis=0)
        pcd.colors[i] = colors
    print(input_filename+" is done")

    #read file with phenospex
    ply=PlyFile()
    ply.load(input_filename)

    colors = np.asarray(pcd.colors)

    # 0-1 aralığındaki renk değerlerini 0-255 aralığına geri çeviriyoruz
    colors = (colors * 255).astype(np.uint8)

    # ply.vertices['red'], 'green', 'blue' sütunlarını dolduruyoruz
    ply.vertices["red"] = colors[:, 0]  # Red kanalını atıyoruz
    ply.vertices["green"] = colors[:, 1]  # Green kanalını atıyoruz
    ply.vertices["blue"] = colors[:, 2]  # Blue kanalını atıyoruz


    #verileri koordinat bilgilerine göre birleştir ve devam et
    ply.write(output_filename)

def smoothing4Paris(input_filename, output_filename,adj_count=10):
    df = pd.read_csv(input_filename, header=None)
    point_data = df.to_numpy()
    # Create an Open3D point cloud from the NumPy array
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(point_data[:, :3])  # Set x, y, z coordinates
    pcd.colors = o3d.utility.Vector3dVector(point_data[:, [3, 4, 4]])  # Set intensity as color

    pcd_tree = o3d.geometry.KDTreeFlann(pcd)
    for i in range(np.asarray(pcd.points).shape[0]):
        adj_index = pcd_tree.search_knn_vector_3d(pcd.points[i], adj_count)
        colors = np.mean(np.asarray(pcd.colors)[adj_index[1], :], axis=0)
        pcd.colors[i][0] = colors[0]
    print(input_filename + " is done")

    # Extract point coordinates and colors from the Open3D point cloud
    points = np.asarray(pcd.points)
    colors = np.asarray(pcd.colors)
    # Combine point coordinates and colors into a new NumPy array
    new_data = np.column_stack((points, colors[:, :2]))
    np.savetxt(output_filename, new_data, delimiter=',', fmt='%.2f')

def merge2ply(file1,file2,outputFolder):
    pcd1 = o3d.io.read_point_cloud(file1)
    pcd2 = o3d.io.read_point_cloud(file2)
    pcd1.points=o3d.utility.Vector3dVector(np.concatenate((np.asarray(pcd1.points),np.asarray(pcd2.points)),axis=0))
    pcd1.colors=o3d.utility.Vector3dVector(np.concatenate((np.asarray(pcd1.colors),np.asarray(pcd2.colors)),axis=0))
    o3d.io.write_point_cloud(outputFolder , pcd1)

def mergePlyWithinFolder(inputFolder,outputFolder):
    subfile_directory = os.listdir(inputFolder)
    pcd=None
    for i, subfile in enumerate(subfile_directory):
        temp = o3d.io.read_point_cloud(inputFolder + "/" + subfile)
        if pcd==None:
            pcd=temp
        else:
            pcd.points=o3d.utility.Vector3dVector(np.concatenate((np.asarray(pcd.points),np.asarray(temp.points)),axis=0))
            pcd.colors=o3d.utility.Vector3dVector(np.concatenate((np.asarray(pcd.colors),np.asarray(temp.colors)),axis=0))
    o3d.io.write_point_cloud(outputFolder + "_" + subfile[-26:] , pcd)


def mergePlyWithinFolderPhenospex(inputFolder,outputFolder):
    subfile_directory = os.listdir(inputFolder)
    ply=None
    for i, subfile in enumerate(subfile_directory):
        temp = PlyFile()
        temp.load(inputFolder + "/" + subfile)
        if ply==None:
            ply=temp
        else:
            ply.elements["vertex"]["count"]=ply.elements["vertex"]["count"] +temp.elements["vertex"]["count"]
            ply.vertices=np.concatenate((np.asarray(ply.vertices),np.asarray(temp.vertices)),axis=0)

    ## set header
    # Find the position of "vertex_count" and its value
    start_index = ply.header.find("vertex_count") + len("vertex_count") + 3
    end_index = ply.header.find(",", start_index)
    ply.header = ply.header[:start_index] + str(ply.elements["vertex"]["count"]) + ply.header[end_index:]

    # Find the position of "element vertex" and its value
    start_index = ply.header.find("element vertex ") + len("element vertex") + 1
    end_index = ply.header.find("\n", start_index)
    ply.header = ply.header[:start_index] + str(ply.elements["vertex"]["count"]) + ply.header[end_index:]

    ply.write(outputFolder + "_" + subfile[-26:] )

def InverseCoordZ(input_filename, output_filename):
    pcd = o3d.io.read_point_cloud(input_filename)
    verts=np.asarray(pcd.points)
    verts[:, 2] =verts[:, 2]*-1
    vectors =  o3d.utility.Vector3dVector(verts)
    pcd.points = vectors
    o3d.io.write_point_cloud(output_filename, pcd)
    return pcd

def ply2png(input_filename, output_filename):
    pcd = o3d.io.read_point_cloud(input_filename)
    equ = cv2.equalizeHist((np.asarray(pcd.colors)*255).astype(np.uint8))
    pcd.colors = o3d.utility.Vector3dVector(equ.astype(np.float32)/255)
    vis = o3d.visualization.Visualizer()
    vis.create_window(width = 300, height=500,  visible=True)
    vis.create_window()
    vis.add_geometry(pcd)
    #o3d.visualization.ViewControl.set_zoom(vis.get_view_control(), 0.7)
    vis.capture_screen_image(output_filename[:-3]+".png",True)

def evaluateResults(y_test,y_pred):
    # Calculate accuracy
    accuracy = accuracy_score(y_test, y_pred)

    # Calculate precision
    precision = precision_score(y_test, y_pred)

    # Calculate recall
    recall = recall_score(y_test, y_pred)

    # Calculate F1 score
    f1 = f1_score(y_test, y_pred)

    # Print the evaluation metrics
    print("Accuracy:", accuracy)
    print("Precision:", precision)
    print("Recall:", recall)
    print("F1 Score:", f1)
    return accuracy,precision,recall,f1

def read_parameter_json():
    # Open the file containing the JSON data
    with open('./PhenoSpexExe/preprocessing.json', 'r') as file:
        # Read the contents of the file
        data = file.read()

    # Load the JSON string into a Python dictionary
    dictionary = json.loads(data)
    return dictionary

def convertOurOutput2PhenospexFormat_OneFile(input_filename, output_filename):
    # pcd = o3d.io.read_point_cloud(input_filename)
    # data=np.concatenate((np.asarray(pcd.points),np.asarray(pcd.colors)),axis=1)
    data = np.loadtxt(input_filename, delimiter=',')
    # Step 2: Write PLY header
    header = """ply
    format ascii 1.0
    element vertex {}
    property float x
    property float y
    property float z
    property uchar red
    property uchar green
    property uchar blue
    property int unit_id
    end_header
    """.format(len(data))
    if len(data)< 10:
        return
    data[:, 2]=data[:, 2]*-1
    vertices = np.zeros(data.shape[0], dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4'), ('red', 'u1'), ('green', 'u1'), ('blue', 'u1'), ('unit_id', 'i4')])
    vertices['x'] = np.float32(data[:, 0]- np.min(data[:, 0]))
    vertices['y'] = np.float32(data[:, 1]- np.min(data[:, 1]))
    vertices['z'] = np.float32(data[:, 2]- np.min(data[:, 2]))

    vertices['red'] = np.uint8(data[:, 3])
    vertices['green'] = np.uint8(data[:, 4])
    vertices['blue'] = np.uint8(data[:, 5])
    vertices['unit_id'] = np.uint32(1)

    vertex_element = PlyElement.describe(vertices, 'vertex')
    # Save as binary .ply file
    output_file_path = output_filename[:-3]+'ply'
    PlyData([vertex_element], text=False).write(output_file_path)















